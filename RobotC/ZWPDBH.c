#pragma config(Sensor, S1,     leftBumper,     sensorEV3_Touch)
#pragma config(Sensor, S2,     rightBumper,    sensorEV3_Touch)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//task showInfo();
task getDistanceAndDegree();

// GOLOBAL VARIABLES
// variables for scan
float distance = getUSDistance(sonarSensor);
float previousDistance = getUSDistance(sonarSensor);

float targetDegree = 0;
float targetDistance = getUSDistance(sonarSensor);
float previousTargetDistance = getUSDistance(sonarSensor);

bool toScan = false;
int recordedDegree=0;

int TURNINGSPEED = 7;

// variables for test boundary
int MAX_BOUNDARY_EXPECTED = 4*100;
int rightBoundaryDegree = 0;
int leftBoundaryDegree = 0;

// DEFINED FUNCTION
void showInfo() {
	displayBigTextLine(2, "L: %d", leftBoundaryDegree);
	displayBigTextLine(4, "R: %d", rightBoundaryDegree);
}


void turn(int degreeToTurn){
	if (toScan) {startTask(getDistanceAndDegree);}
	degreeToTurn = degreeToTurn * 2;
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	if (degreeToTurn > 0) {
		setMotorTarget(leftMotor, degreeToTurn, TURNINGSPEED);
		setMotorTarget(rightMotor, -degreeToTurn, TURNINGSPEED);
		while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor)) {
			setMotorSync(leftMotor, rightMotor, 100, TURNINGSPEED);
		}
		} else if (degreeToTurn < 0) {
		degreeToTurn = -1 * degreeToTurn;
		setMotorTarget(leftMotor, -degreeToTurn, TURNINGSPEED);
		setMotorTarget(rightMotor, degreeToTurn, TURNINGSPEED);
		while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor)) {
			setMotorSync(leftMotor, rightMotor, -100, TURNINGSPEED);
		}
		if (toScan) {stopTask(getDistanceAndDegree);}
	}

}

void turnOneMotor(bool leftOrRight, int motorEncoder)
{ // leftOrRight, true means turn left(RightMotor move), false mean turn right(LeftMotor move)
	// motorEncoder, is the encoder you want the wheel to turn, positive means forward, negative means backward
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	if(leftOrRight) { // it means turn left, rightMotor move while leftMotor stop
			if (motorEncoder > 0) { // move forward
					setMotorTarget(rightMotor, motorEncoder, TURNINGSPEED);
					while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor)) {
							setMotorSync(leftMotor, rightMotor, -50, TURNINGSPEED);
					}
			} else if (motorEncoder<0) { // move backward
					setMotorTarget(rightMotor, -motorEncoder, TURNINGSPEED);
					while(getMotorEncoder(rightMotor)!= - getMotorTarget(rightMotor)) {
							setMotorSync(leftMotor, rightMotor, -50, -TURNINGSPEED);
					}
			}
	} else {	// else, it means turn right, LeftMotor move while RightMotor stop
			if (motorEncoder > 0) {
					setMotorTarget(leftMotor, motorEncoder, TURNINGSPEED);
					while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor)) {
							setMotorSync(leftMotor, rightMotor, 50, TURNINGSPEED);
					}
			} else if (motorEncoder < 0) {
					setMotorTarget(leftMotor, -motorEncoder, TURNINGSPEED);
					while(getMotorEncoder(leftMotor)!= - getMotorTarget(leftMotor)){
							setMotorSync(leftMotor, rightMotor, 50, TURNINGSPEED);
					}
			}
	}

}

void scan() {

	int scanDegree = 60;

	// scan right side
	toScan=true;
	turn(scanDegree);
	toScan=false;
	turn(-scanDegree);

	// scan left side
	toScan=true;
	turn(-scanDegree);
	toScan=false;
	turn(scanDegree);

	turn(targetDegree);
}


int turnRightUntilMeetBoundary() {
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	leftBoundaryDegree = 0;

	setMotorTarget(leftMotor, MAX_BOUNDARY_EXPECTED, TURNINGSPEED);
	while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor) && getColorName(colorSensor)==colorBlack) {
		setMotorSync(leftMotor, rightMotor, 50, TURNINGSPEED);
	}
	rightBoundaryDegree = getMotorEncoder(leftMotor);
	// go back to original place
	turnOneMotor()
	resetMotorEncoder(leftMotor);
	setMotorTarget(leftMotor, rightBoundaryDegree, -TURNINGSPEED);
	while(getMotorEncoder(leftMotor) != -getMotorTarget(leftMotor)) {
		setMotorSync(leftMotor,rightMotor, 50, -TURNINGSPEED);
	}

	return rightBoundaryDegree;
}


int turnLeftUntilMeetBoundary() {
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	leftBoundaryDegree = 0;

	setMotorTarget(rightMotor, MAX_BOUNDARY_EXPECTED, TURNINGSPEED);
	while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor) && getColorName(colorSensor)==colorBlack) {
		setMotorSync(leftMotor, rightMotor, -50, TURNINGSPEED);
	}
	leftBoundaryDegree = getMotorEncoder(rightMotor);

	// go back to orginal place
	resetMotorEncoder(rightMotor);
	setMotorTarget(rightMotor, leftBoundaryDegree, -TURNINGSPEED);
	while(getMotorEncoder(rightMotor) != -getMotorTarget(rightMotor)) {
		setMotorSync(leftMotor,rightMotor, -50, -TURNINGSPEED);
	}

	return leftBoundaryDegree;
}



void testBoundary() {
	leftBoundaryDegree = turnLeftUntilMeetBoundary();
	displayBigTextLine(4, "leftBD, %d", leftBoundaryDegree);
	rightBoundaryDegree = turnRightUntilMeetBoundary();
	sleep(5000);
	displayBigTextLine(6, "leftBD, %d", rightBoundaryDegree);

	int differences = abs(rightBoundaryDegree - leftBoundaryDegree);
	//if(leftBoundaryDegree>rightBoundaryDegree) {
	//	turn(-differences/32);
	//	//turn(-3);
	//} else {
	//	//turn(3);
	//	turn(differences/32);
	//}
	if (leftBoundaryDegree>rightBoundaryDegree) {
			resetMotorEncoder(rightMotor);
			setMotorTarget(rightMotor, differences/2, TURNINGSPEED);
			while(getMotorEncoder(rightMotor) != getMotorTarget(rightMotor)) {
				setMotorSync(leftMotor, rightMotor, -50, TURNINGSPEED);
				displayBigTextLine(2, "differences: %d", differences/2);
				displayBigTextLine(4, "Left bigger");

			}
			sleep(30000);
		}

		else {
			resetMotorEncoder(leftMotor);
			setMotorTarget(leftMotor, differences/2, TURNINGSPEED);
			while(getMotorEncoder(leftMotor) != getMotorTarget(leftMotor)) {
				setMotorSync(leftMotor, rightMotor, 50, TURNINGSPEED);
				displayBigTextLine(2, "differences: %d", differences/2);
				displayBigTextLine(4, "Right bigger");
			}
			sleep(30000);
		}
}




task main()
{

	//scan();
	testBoundary();
	//showInfo();
	//while(true) {	setMotorSync(leftMotor, rightMotor, 50, -30);}

	//setMotorTarget(leftMotor, -1000, -50);
	//while(getMotorEncoder(leftMotor)!=-getMotorTarget(leftMotor)) {
	//		displayBigTextLine(2, "Encoder: %d", getMotorEncoder(leftMotor));
	//		displayBigTextLine(4, "target: %d", getMotorTarget(leftMotor));
	//		setMotorSync(leftMotor, rightMotor, 50, -10);
	//}

}


task getDistanceAndDegree() {
	while(true) {
		recordedDegree = getMotorEncoder(leftMotor)/2;
		distance = getUSDistance(sonarSensor);
		if (distance < previousDistance) {
			previousDistance = distance;
			targetDistance = previousDistance;
			targetDegree = recordedDegree;
		}
	}
}
