#pragma config(Sensor, S1,     leftBumper,     sensorEV3_Touch)
#pragma config(Sensor, S2,     rightBumper,    sensorEV3_Touch)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//task showInfo();
task getDistanceAndDegree();

// GOLOBAL VARIABLES
// variables for scan
bool RIGHT = true;
bool LEFT = false;

float distance = getUSDistance(sonarSensor);
float previousDistance = getUSDistance(sonarSensor);

float targetDegree = 0;
float targetDistance = getUSDistance(sonarSensor);
float previousTargetDistance = getUSDistance(sonarSensor);

bool toScan = false;
int recordedDegree=0;

int TURNINGSPEED = 7;

// variables for test boundary
int MAX_BOUNDARY_EXPECTED = 4*100;
int rightBoundaryDegree = 0;
int leftBoundaryDegree = 0;

// DEFINED FUNCTION
void showInfo() {
	displayBigTextLine(2, "L: %d", leftBoundaryDegree);
	displayBigTextLine(4, "R: %d", rightBoundaryDegree);
}


void turn(int degreeToTurn){
	if (toScan) {startTask(getDistanceAndDegree);}
	degreeToTurn = degreeToTurn * 2;
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	if (degreeToTurn > 0) {
		setMotorTarget(leftMotor, degreeToTurn, TURNINGSPEED);
		setMotorTarget(rightMotor, -degreeToTurn, TURNINGSPEED);
		while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor)) {
			setMotorSync(leftMotor, rightMotor, 100, TURNINGSPEED);
		}
		} else if (degreeToTurn < 0) {
		degreeToTurn = -1 * degreeToTurn;
		setMotorTarget(leftMotor, -degreeToTurn, TURNINGSPEED);
		setMotorTarget(rightMotor, degreeToTurn, TURNINGSPEED);
		while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor)) {
			setMotorSync(leftMotor, rightMotor, -100, TURNINGSPEED);
		}
		if (toScan) {stopTask(getDistanceAndDegree);}
	}

}





void turnOneMotor(bool leftMotorOrRightMotor, int motorEncoder)
{ // leftMotorOrRightMotor:
	// true, turn RIGHT motor,
	// false, turn LEFT motor.
	// motorEncoder, is the encoder you want the wheel to turn, positive means forward, negative means backward
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	if(leftMotorOrRightMotor) { // RightMotor move while LeftMotor stop
		if (motorEncoder > 0) { // move forward
			setMotorTarget(rightMotor, motorEncoder, TURNINGSPEED);
			while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor)) {
				setMotorSync(leftMotor, rightMotor, -50, TURNINGSPEED);
			}
			} else if (motorEncoder<0) { // move backward
			setMotorTarget(rightMotor, -motorEncoder, TURNINGSPEED);
			while(getMotorEncoder(rightMotor)!= - getMotorTarget(rightMotor)) {
				setMotorSync(leftMotor, rightMotor, -50, -TURNINGSPEED);
			}
		}
		} else {	// else false, LeftMotor move while RightMotor stop
		if (motorEncoder > 0) {
			setMotorTarget(leftMotor, motorEncoder, TURNINGSPEED);
			while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor)) {
				setMotorSync(leftMotor, rightMotor, 50, TURNINGSPEED);
			}
			} else if (motorEncoder < 0) {
			setMotorTarget(leftMotor, -motorEncoder, TURNINGSPEED);
			while(getMotorEncoder(leftMotor)!= - getMotorTarget(leftMotor)){
				setMotorSync(leftMotor, rightMotor, 50, TURNINGSPEED);
			}
		}
	}
}



void scan() {

	int scanDegree = 60;

	// scan right side
	toScan=true;
	turn(scanDegree);
	toScan=false;
	turn(-scanDegree);

	// scan left side
	toScan=true;
	turn(-scanDegree);
	toScan=false;
	turn(scanDegree);

	turn(targetDegree);
}


int turnRightUntilMeetBoundary() {
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	leftBoundaryDegree = 0;

	setMotorTarget(leftMotor, MAX_BOUNDARY_EXPECTED, TURNINGSPEED);
	while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor) && getColorName(colorSensor)==colorBlack) {
		setMotorSync(leftMotor, rightMotor, 50, TURNINGSPEED);
	}
	rightBoundaryDegree = getMotorEncoder(leftMotor);
	// go back to original place
	turnOneMotor(LEFT, -rightBoundaryDegree);
	//resetMotorEncoder(leftMotor);
	//setMotorTarget(leftMotor, rightBoundaryDegree, -TURNINGSPEED);
	//while(getMotorEncoder(leftMotor) != -getMotorTarget(leftMotor)) {
	//	setMotorSync(leftMotor,rightMotor, 50, -TURNINGSPEED);
	//}

	return rightBoundaryDegree;
}


int turnLeftUntilMeetBoundary() {
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	leftBoundaryDegree = 0;

	setMotorTarget(rightMotor, MAX_BOUNDARY_EXPECTED, TURNINGSPEED);
	while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor) && getColorName(colorSensor)==colorBlack) {
		setMotorSync(leftMotor, rightMotor, -50, TURNINGSPEED);
	}
	leftBoundaryDegree = getMotorEncoder(rightMotor);

	// go back to orginal place
	turnOneMotor(RIGHT, -leftBoundaryDegree);
	//resetMotorEncoder(rightMotor);
	//setMotorTarget(rightMotor, leftBoundaryDegree, -TURNINGSPEED);
	//while(getMotorEncoder(rightMotor) != -getMotorTarget(rightMotor)) {
	//	setMotorSync(leftMotor,rightMotor, -50, -TURNINGSPEED);
	//}
	return leftBoundaryDegree;
}

int turnOneMotorUntilMeetBoundary(bool leftOrRightMotor) {
		resetMotorEncoder(leftMotor);
		resetMotorEncoder(rightMotor);

		int saved_leftBoundaryDegree = 0;
		int saved_rightBoundaryDegree = 0;

		if(leftOrRightMotor) {
			 // turn RightMotor
			setMotorTarget(rightMotor, MAX_BOUNDARY_EXPECTED, TURNINGSPEED);
			while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor) && getColorName(colorSensor)==colorBlack) {
				setMotorSync(leftMotor, rightMotor, -50, TURNINGSPEED);
			}

			saved_leftBoundaryDegree = getMotorEncoder(rightMotor);
			turnOneMotor(RIGHT, -1*saved_leftBoundaryDegree);
			return saved_leftBoundaryDegree
		} else {
			setMotorTarget(leftMotor, MAX_BOUNDARY_EXPECTED, TURNINGSPEED);
			while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor) && getColorName(colorSensor)==colorBlack) {
				setMotorSync(leftMotor, rightMotor, 50, TURNINGSPEED);
			}

			saved_rightBoundaryDegree = getMotorEncoder(leftMotor);
			turnOneMotor(LEFT, -1*saved_rightBoundaryDegree);
			return saved_rightBoundaryDegree;
		}
}



void testBoundary() {
	//leftBoundaryDegree = turnLeftUntilMeetBoundary();
	//rightBoundaryDegree = turnRightUntilMeetBoundary();

	leftBoundaryDegree = turnOneMotorUntilMeetBoundary(RIGHT);
	rightBoundaryDegree = turnOneMotorUntilMeetBoundary(LEFT);

	int differences = abs(rightBoundaryDegree - leftBoundaryDegree);
	if(leftBoundaryDegree>rightBoundaryDegree) {
		turn(-differences/27);
		} else {
		turn(differences/27);
	}

}




task main()
{
	//scan();
	testBoundary();
	//showInfo();
	//while(true) {	setMotorSync(leftMotor, rightMotor, 50, -30);}

	//setMotorTarget(leftMotor, -1000, -50);
	//while(getMotorEncoder(leftMotor)!=-getMotorTarget(leftMotor)) {
	//		displayBigTextLine(2, "Encoder: %d", getMotorEncoder(leftMotor));
	//		displayBigTextLine(4, "target: %d", getMotorTarget(leftMotor));
	//		setMotorSync(leftMotor, rightMotor, 50, -10);
	//}

}


task getDistanceAndDegree() {
	while(true) {
		recordedDegree = getMotorEncoder(leftMotor)/2;
		distance = getUSDistance(sonarSensor);
		if (distance < previousDistance) {
			previousDistance = distance;
			targetDistance = previousDistance;
			targetDegree = recordedDegree;
		}
	}
}
