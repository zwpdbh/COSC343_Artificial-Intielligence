Frank



Drive
My Drive
NEW 
Folders and views
My DriveMy Drive
Shared with meShared with me
Google PhotosGoogle Photos
RecentRecent
StarredStarred
TrashTrash
601 MB of 15 GB used
Upgrade storage
Get Drive for Mac
.

PDF
Artificial Intelligence A Modern Approach 3rd Edition.pdf

PDF
Data.Communications.and.Networking.5th.Edition.pdf

PDF
Foundations of Python network programming.pdf

PDF
Getting started

PDF
head_first_design_patterns.pdf

PDF
Introduction to Algorithms 3rd Edition Sep 2010.pdf

Compressed Archive
Introduction to Algorithms 3rd Edition.pdf.zip

PDF
Introductory Statistics by Prem S. Mann .pdf

PDF
Introductory Statistics by Prem S. Mann .pdf

PDF
LEARNING PYTHON POWERFUL OBJECT-ORIENTED PROGRAMMING, 5TH EDITION-OREILLY.pdf

PDF
Linear Algebra, A Modern Introduction- David Poole.pdf

PDF
Pattern Recognition and Machine Learning.pdf

PDF
Programming Python 4th.Edition O'Reilly.pdf

PDF
Web Scraping with Python.pdf

C
ZWPDBH_NewOne.c


#pragma config(Sensor, S1,     leftBumper,     sensorEV3_Touch)
#pragma config(Sensor, S2,     rightBumper,    sensorEV3_Touch)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


task getDistanceAndDegree();

// GOLOBAL VARIABLES
int totalBlackTile = 0;
int MOVINGSPEED = 30;

// variables for scan
bool RIGHT = true;
bool LEFT = false;

float distance = getUSDistance(sonarSensor);
float previousDistance = getUSDistance(sonarSensor);

float targetDegree = 0;
float targetDistance = getUSDistance(sonarSensor);

bool toScan = false;
int recordedDegree=0;

int TURNINGSPEED = 7;

// variables for test boundary
int MAX_BOUNDARY_EXPECTED = 4*100;
int rightBoundaryDegree = 0;
int leftBoundaryDegree = 0;

// DEFINED FUNCTION


void turn(int degreeToTurn){
	if (toScan) {startTask(getDistanceAndDegree);}
	degreeToTurn = degreeToTurn * 2;
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	if (degreeToTurn > 0) {
		setMotorTarget(leftMotor, degreeToTurn, TURNINGSPEED);
		setMotorTarget(rightMotor, -degreeToTurn, TURNINGSPEED);
		while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor)) {
			setMotorSync(leftMotor, rightMotor, 100, TURNINGSPEED);
		}
		} else if (degreeToTurn < 0) {
		degreeToTurn = -1 * degreeToTurn;
		setMotorTarget(leftMotor, -degreeToTurn, TURNINGSPEED);
		setMotorTarget(rightMotor, degreeToTurn, TURNINGSPEED);
		while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor)) {
			setMotorSync(leftMotor, rightMotor, -100, TURNINGSPEED);
		}
		if (toScan) {stopTask(getDistanceAndDegree);}
	}

}



void scan() {
	int scanDegree = 60;
	// scan right side
	toScan=true;
	turn(scanDegree);
	toScan=false;
	turn(-scanDegree);
	// scan left side
	toScan=true;
	turn(-scanDegree);
	toScan=false;
	turn(scanDegree);

	turn(targetDegree);
}


void turnOneMotor(bool leftMotorOrRightMotor, int motorEncoder)
{ // leftMotorOrRightMotor:
	// true, turn RIGHT motor,
	// false, turn LEFT motor.
	// motorEncoder, is the encoder you want the wheel to turn, positive means forward, negative means backward
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	if(leftMotorOrRightMotor) { // RightMotor move while LeftMotor stop
		if (motorEncoder > 0) { // move forward
			setMotorTarget(rightMotor, motorEncoder, TURNINGSPEED);
			while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor)) {
				setMotorSync(leftMotor, rightMotor, -50, TURNINGSPEED);
			}
			} else if (motorEncoder<0) { // move backward
			setMotorTarget(rightMotor, -motorEncoder, TURNINGSPEED);
			while(getMotorEncoder(rightMotor)!= -1*getMotorTarget(rightMotor)) {
				setMotorSync(leftMotor, rightMotor, -50, -TURNINGSPEED);
			}
		}
		} else {	// else false, LeftMotor move while RightMotor stop
		if (motorEncoder > 0) {
			setMotorTarget(leftMotor, motorEncoder, TURNINGSPEED);
			while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor)) {
				setMotorSync(leftMotor, rightMotor, 50, TURNINGSPEED);
			}
			} else if (motorEncoder < 0) {
			setMotorTarget(leftMotor, -motorEncoder, TURNINGSPEED);
			while(getMotorEncoder(leftMotor)!= -1*getMotorTarget(leftMotor)){
				setMotorSync(leftMotor, rightMotor, 50, -TURNINGSPEED);
			}
		}
	}
}


int turnOneMotorUntilMeetBoundary(bool leftOrRightMotor) {
		resetMotorEncoder(leftMotor);
		resetMotorEncoder(rightMotor);

		int saved_leftBoundaryDegree = 0;
		int saved_rightBoundaryDegree = 0;

		if(leftOrRightMotor) {
			 // turn RightMotor
			setMotorTarget(rightMotor, MAX_BOUNDARY_EXPECTED, TURNINGSPEED);
			while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor) && getColorName(colorSensor)==colorBlack) {
				setMotorSync(leftMotor, rightMotor, -50, TURNINGSPEED);
			}

			saved_leftBoundaryDegree = getMotorEncoder(rightMotor);
			turnOneMotor(RIGHT, -1*saved_leftBoundaryDegree);
			return saved_leftBoundaryDegree;

		} else {
			setMotorTarget(leftMotor, MAX_BOUNDARY_EXPECTED, TURNINGSPEED);
			while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor) && getColorName(colorSensor)==colorBlack) {
				setMotorSync(leftMotor, rightMotor, 50, TURNINGSPEED);
			}

			saved_rightBoundaryDegree = getMotorEncoder(leftMotor);
			turnOneMotor(LEFT, -1*saved_rightBoundaryDegree);
			return saved_rightBoundaryDegree;
		}
}


void testBoundary() {

	leftBoundaryDegree = turnOneMotorUntilMeetBoundary(RIGHT);
	rightBoundaryDegree = turnOneMotorUntilMeetBoundary(LEFT);
	int differences = abs(rightBoundaryDegree - leftBoundaryDegree);
	if(leftBoundaryDegree>rightBoundaryDegree) {
		turnOneMotor(RIGHT, differences/4);
		// turn(-differences/20);
		} else {
		turnOneMotor(LEFT, differences/4);
		//turn(differences/20);
	}

}

void moveForwardWithSpeed(int movingSpeed) {
		TLegoColors previousColor = getColorName(colorSensor); // it should be black at start
		TLegoColors currentColor = getColorName(colorSensor);	// it should be black at start
		int count = 0;
		while(count<=1){
			setMotorSync(leftMotor, rightMotor, 0, movingSpeed);
			currentColor = getColorName(colorSensor);						// now robot enter the white tile.
			if (currentColor == colorWhite) {
					previousColor = colorWhite;
			} else if(currentColor == colorBlack && previousColor == colorWhite) {
					count++;
					previousColor = colorBlack;
					totalBlackTile++;
					playSound(soundUpwardTones);
			}
		}
		sleep(200);
}


task main()
{
	while(totalBlackTile<=5) {
		moveForwardWithSpeed(MOVINGSPEED);
		testBoundary();
	}

}


task getDistanceAndDegree() {
	while(true) {
		recordedDegree = getMotorEncoder(leftMotor)/2;
		distance = getUSDistance(sonarSensor);
		if (distance < previousDistance) {
			previousDistance = distance;
			targetDistance = previousDistance;
			targetDegree = recordedDegree;
		}
	}
}
