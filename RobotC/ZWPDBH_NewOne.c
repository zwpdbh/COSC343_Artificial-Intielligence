#pragma config(Sensor, S1,     leftBumper,     sensorEV3_Touch)
#pragma config(Sensor, S2,     rightBumper,    sensorEV3_Touch)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
// GOLOBAL VARIABLES
int totalBlackTile = 0;
int MOVINGSPEED = 10;

// variables for scan
bool RIGHT = true;
bool LEFT = false;

int TURNINGSPEED = 7;

// variables for test boundary
int MAX_BOUNDARY_EXPECTED = 4*100;
int rightBoundaryDegree = 0;
int leftBoundaryDegree = 0;


// DEFINED FUNCTION
bool approachingTarget = false;
void turn(int degreeToTurn){
    int previousDistance = getUSDistance(sonarSensor);
    int currentDistance = getUSDistance(sonarSensor);
    
    degreeToTurn = degreeToTurn * 2;
    resetMotorEncoder(leftMotor);
    resetMotorEncoder(rightMotor);
    if (degreeToTurn >= 0) {
        setMotorTarget(leftMotor, degreeToTurn, TURNINGSPEED);
        setMotorTarget(rightMotor, -degreeToTurn, TURNINGSPEED);
        while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor) && getTouchValue(leftBumper)!=1 && getTouchValue(rightBumper)!=1) {
            setMotorSync(leftMotor, rightMotor, 100, TURNINGSPEED);
            currentDistance = getUSDistance(sonarSensor);
            if (currentDistance<previousDistance) {
                previousDistance = currentDistance; // it means it is turning toward to target;
                approachingTarget = true;
            } else if (approachingTarget && currentDistance > previousDistance) {
                return;
            }
        }
    } else if (degreeToTurn <= 0) {
        degreeToTurn = -1 * degreeToTurn;
        setMotorTarget(leftMotor, -degreeToTurn, TURNINGSPEED);
        setMotorTarget(rightMotor, degreeToTurn, TURNINGSPEED);
        while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor)&& getTouchValue(leftBumper)!=1 && getTouchValue(rightBumper)!=1) {
            setMotorSync(leftMotor, rightMotor, -100, TURNINGSPEED);
            currentDistance = getUSDistance(sonarSensor);
            if (currentDistance<previousDistance) {
                previousDistance = currentDistance; // it means it is turning toward to target;
                approachingTarget = true;
            } else if (approachingTarget && currentDistance > previousDistance) {
                return;
            }
        }
    }
}



void scan() {
    approachingTarget = false;
    int scanDegree = 45;
    if(getTouchValue(leftBumper)==1){return;}
    while(!approachingTarget) {
        turn(scanDegree);
        if (approachingTarget) {break;}
        turn(-scanDegree*2);
        if (approachingTarget) {break;}
        turn(scanDegree);
    }
}


void turnOneMotor(bool leftMotorOrRightMotor, int motorEncoder)
{ // leftMotorOrRightMotor:
    // true, turn RIGHT motor,
    // false, turn LEFT motor.
    // motorEncoder, is the encoder you want the wheel to turn, positive means forward, negative means backward
    resetMotorEncoder(leftMotor);
    resetMotorEncoder(rightMotor);
    
    if(leftMotorOrRightMotor) { // RightMotor move while LeftMotor stop
        if (motorEncoder > 0) { // move forward
            setMotorTarget(rightMotor, motorEncoder, TURNINGSPEED);
            while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor)) {
                setMotorSync(leftMotor, rightMotor, -50, TURNINGSPEED);
            }
        } else if (motorEncoder<0) { // move backward
            setMotorTarget(rightMotor, -motorEncoder, TURNINGSPEED);
            while(getMotorEncoder(rightMotor)!= -1*getMotorTarget(rightMotor)) {
                setMotorSync(leftMotor, rightMotor, -50, -TURNINGSPEED);
            }
        }
    } else {	// else false, LeftMotor move while RightMotor stop
        if (motorEncoder > 0) {
            setMotorTarget(leftMotor, motorEncoder, TURNINGSPEED);
            while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor)) {
                setMotorSync(leftMotor, rightMotor, 50, TURNINGSPEED);
            }
        } else if (motorEncoder < 0) {
            setMotorTarget(leftMotor, -motorEncoder, TURNINGSPEED);
            while(getMotorEncoder(leftMotor)!= -1*getMotorTarget(leftMotor)){
                setMotorSync(leftMotor, rightMotor, 50, -TURNINGSPEED);
            }
        }
    }
}


int turnOneMotorUntilMeetBoundary(bool leftOrRightMotor) {
    resetMotorEncoder(leftMotor);
    resetMotorEncoder(rightMotor);
    
    int saved_leftBoundaryDegree = 0;
    int saved_rightBoundaryDegree = 0;
    
    if(leftOrRightMotor) {
        // turn RightMotor
        setMotorTarget(rightMotor, MAX_BOUNDARY_EXPECTED, TURNINGSPEED);
        while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor) && getColorName(colorSensor)==colorBlack) {
            setMotorSync(leftMotor, rightMotor, -50, TURNINGSPEED);
        }
        
        saved_leftBoundaryDegree = getMotorEncoder(rightMotor);
        turnOneMotor(RIGHT, -1*saved_leftBoundaryDegree);
        return saved_leftBoundaryDegree;
        
    } else {
        setMotorTarget(leftMotor, MAX_BOUNDARY_EXPECTED, TURNINGSPEED);
        while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor) && getColorName(colorSensor)==colorBlack) {
            setMotorSync(leftMotor, rightMotor, 50, TURNINGSPEED);
        }
        
        saved_rightBoundaryDegree = getMotorEncoder(leftMotor);
        turnOneMotor(LEFT, -1*saved_rightBoundaryDegree);
        return saved_rightBoundaryDegree;
    }
}


void testBoundary() {
    leftBoundaryDegree = turnOneMotorUntilMeetBoundary(RIGHT);
    rightBoundaryDegree = turnOneMotorUntilMeetBoundary(LEFT);
    int differences = abs(rightBoundaryDegree - leftBoundaryDegree);
    if(leftBoundaryDegree>rightBoundaryDegree) {
        turnOneMotor(RIGHT, differences/4);
        // turn(-differences/20);
    } else {
        turnOneMotor(LEFT, differences/4);
        //turn(differences/20);
    }
    
}

void moveForwardWithSpeed(int movingSpeed) {
    TLegoColors previousColor = getColorName(colorSensor); // it should be black at start
    TLegoColors currentColor = getColorName(colorSensor);	// it should be black at start
    int count = 0;
    while(count<1 && getTouchValue(leftBumper)!=1){
        setMotorSync(leftMotor, rightMotor, 0, movingSpeed);
        currentColor = getColorName(colorSensor);						// now robot enter the white tile.
        if (currentColor == colorWhite) {
            previousColor = colorWhite;
        } else if(currentColor == colorBlack && previousColor == colorWhite) {
            count++;
            previousColor = colorBlack;
            totalBlackTile++;
            playSound(soundUpwardTones);
        }
    }
    sleep(200);
}


void moveToLine(){
    moveForwardWithSpeed(MOVINGSPEED);
    turnOneMotor(RIGHT, 300);
    
}

task main()
{
    //stage one
    moveToLine();
    while(totalBlackTile<5) {
        moveForwardWithSpeed(MOVINGSPEED);
        testBoundary();
    }
    
    turnOneMotor(LEFT, 300);
    
    
    // stage two
    while (getTouchValue(leftBumper)==0&&getTouchValue(rightBumper)==0){
        moveForwardWithSpeed(MOVINGSPEED);
        scan();
    }
    setMotorSyncTime(leftMotor, rightMotor, 0, 2000, 30);
    wait1Msec(2000);
    playSound(soundUpwardTones);
    wait1Msec(1000);
    
}
