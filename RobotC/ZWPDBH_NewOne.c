#pragma config(Sensor, S1,     leftBumper,     sensorEV3_Touch)
#pragma config(Sensor, S2,     rightBumper,    sensorEV3_Touch)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


task getDistanceAndDegree();

// GOLOBAL VARIABLES
int totalBlackTile = 0;
int MOVINGSPEED = 10;

// variables for scan
bool bumps = true;
bool RIGHT = true;
bool LEFT = false;

float distance = getUSDistance(sonarSensor);
float previousDistance = getUSDistance(sonarSensor);

float targetDegree = 0;
float targetDistance = getUSDistance(sonarSensor);

bool toScan = false;
int recordedDegree=0;

int TURNINGSPEED = 7;

// variables for test boundary
int MAX_BOUNDARY_EXPECTED = 4*100;
int rightBoundaryDegree = 0;
int leftBoundaryDegree = 0;


// DEFINED FUNCTION


void turn(int degreeToTurn){
	if (toScan) {startTask(getDistanceAndDegree);}
	degreeToTurn = degreeToTurn * 2;
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	if (degreeToTurn > 0) {
		if(getTouchValue(leftBumper)==1){return;}
		setMotorTarget(leftMotor, degreeToTurn, TURNINGSPEED);
		setMotorTarget(rightMotor, -degreeToTurn, TURNINGSPEED);
		while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor)) {
			setMotorSync(leftMotor, rightMotor, 100, TURNINGSPEED);
		}
		} else if (degreeToTurn < 0) {
		if(getTouchValue(leftBumper)==1){return;}
		degreeToTurn = -1 * degreeToTurn;
		setMotorTarget(leftMotor, -degreeToTurn, TURNINGSPEED);
		setMotorTarget(rightMotor, degreeToTurn, TURNINGSPEED);
		while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor)) {
			setMotorSync(leftMotor, rightMotor, -100, TURNINGSPEED);
		}
		if (toScan) {stopTask(getDistanceAndDegree);}
	}

}



void scan() {
	if(getTouchValue(leftBumper)==1){return;}
	int scanDegree = 60;
	// scan right side
	toScan=true;
	turn(scanDegree);
	toScan=false;
	turn(-scanDegree);
	// scan left side
	toScan=true;
	turn(-scanDegree);
	toScan=false;
	turn(scanDegree);

	turn(targetDegree);
}


void turnOneMotor(bool leftMotorOrRightMotor, int motorEncoder)
{ // leftMotorOrRightMotor:
	// true, turn RIGHT motor,
	// false, turn LEFT motor.
	// motorEncoder, is the encoder you want the wheel to turn, positive means forward, negative means backward
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	if(leftMotorOrRightMotor) { // RightMotor move while LeftMotor stop
		if (motorEncoder > 0) { // move forward
			setMotorTarget(rightMotor, motorEncoder, TURNINGSPEED);
			while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor)) {
				setMotorSync(leftMotor, rightMotor, -50, TURNINGSPEED);
			}
			} else if (motorEncoder<0) { // move backward
			setMotorTarget(rightMotor, -motorEncoder, TURNINGSPEED);
			while(getMotorEncoder(rightMotor)!= -1*getMotorTarget(rightMotor)) {
				setMotorSync(leftMotor, rightMotor, -50, -TURNINGSPEED);
			}
		}
		} else {	// else false, LeftMotor move while RightMotor stop
		if (motorEncoder > 0) {
			setMotorTarget(leftMotor, motorEncoder, TURNINGSPEED);
			while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor)) {
				setMotorSync(leftMotor, rightMotor, 50, TURNINGSPEED);
			}
			} else if (motorEncoder < 0) {
			setMotorTarget(leftMotor, -motorEncoder, TURNINGSPEED);
			while(getMotorEncoder(leftMotor)!= -1*getMotorTarget(leftMotor)){
				setMotorSync(leftMotor, rightMotor, 50, -TURNINGSPEED);
			}
		}
	}
}


int turnOneMotorUntilMeetBoundary(bool leftOrRightMotor) {
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	int saved_leftBoundaryDegree = 0;
	int saved_rightBoundaryDegree = 0;

	if(leftOrRightMotor) {
		// turn RightMotor
		setMotorTarget(rightMotor, MAX_BOUNDARY_EXPECTED, TURNINGSPEED);
		while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor) && getColorName(colorSensor)==colorBlack) {
			setMotorSync(leftMotor, rightMotor, -50, TURNINGSPEED);
		}

		saved_leftBoundaryDegree = getMotorEncoder(rightMotor);
		turnOneMotor(RIGHT, -1*saved_leftBoundaryDegree);
		return saved_leftBoundaryDegree;

		} else {
		setMotorTarget(leftMotor, MAX_BOUNDARY_EXPECTED, TURNINGSPEED);
		while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor) && getColorName(colorSensor)==colorBlack) {
			setMotorSync(leftMotor, rightMotor, 50, TURNINGSPEED);
		}

		saved_rightBoundaryDegree = getMotorEncoder(leftMotor);
		turnOneMotor(LEFT, -1*saved_rightBoundaryDegree);
		return saved_rightBoundaryDegree;
	}
}


void testBoundary() {

	leftBoundaryDegree = turnOneMotorUntilMeetBoundary(RIGHT);
	rightBoundaryDegree = turnOneMotorUntilMeetBoundary(LEFT);
	int differences = abs(rightBoundaryDegree - leftBoundaryDegree);
	if(leftBoundaryDegree>rightBoundaryDegree) {
		turnOneMotor(RIGHT, differences/4);
		// turn(-differences/20);
		} else {
		turnOneMotor(LEFT, differences/4);
		//turn(differences/20);
	}

}

void moveForwardWithSpeed(int movingSpeed) {
	TLegoColors previousColor = getColorName(colorSensor); // it should be black at start
	TLegoColors currentColor = getColorName(colorSensor);	// it should be black at start
	int count = 0;
	while(count<1 && getTouchValue(leftBumper)!=1){
		setMotorSync(leftMotor, rightMotor, 0, movingSpeed);
		currentColor = getColorName(colorSensor);						// now robot enter the white tile.
		if (currentColor == colorWhite) {
			previousColor = colorWhite;
			} else if(currentColor == colorBlack && previousColor == colorWhite) {
			count++;
			previousColor = colorBlack;
			totalBlackTile++;
			playSound(soundUpwardTones);
		}
	}
	sleep(200);
}


void moveToLine(){
	moveForwardWithSpeed(MOVINGSPEED);
	turnOneMotor(RIGHT, 300);

}

task main()
{
	//stage one
	moveToLine();
	while(totalBlackTile<5) {
		moveForwardWithSpeed(MOVINGSPEED);
		testBoundary();
	}

	turnOneMotor(LEFT, 300);


	// stage two
	while (getTouchValue(leftBumper)==0&&getTouchValue(rightBumper)==0){
		moveForwardWithSpeed(MOVINGSPEED);
		scan();
	}
	setMotorSyncTime(leftMotor, rightMotor, 0, 2000, 30);
	wait1Msec(2000);
	playSound(soundUpwardTones);
	wait1Msec(1000);

}


task getDistanceAndDegree() {
	if(getTouchValue(leftBumper)==1){return;}
	while(true) {
		recordedDegree = getMotorEncoder(leftMotor)/2;
		distance = getUSDistance(sonarSensor);
		if (distance < previousDistance) {
			previousDistance = distance;
			targetDistance = previousDistance;
			targetDegree = recordedDegree;
		}
	}
}
