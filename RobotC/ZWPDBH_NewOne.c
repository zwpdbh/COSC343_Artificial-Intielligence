#pragma config(Sensor, S1,     leftBumper,     sensorEV3_Touch)
#pragma config(Sensor, S2,     rightBumper,    sensorEV3_Touch)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//task showInfo();
task getDistanceAndDegree();

// GOLOBAL VARIABLES
// variables for scan
bool RIGHT = true;
bool LEFT = false;

float distance = getUSDistance(sonarSensor);
float previousDistance = getUSDistance(sonarSensor);

float targetDegree = 0;
float targetDistance = getUSDistance(sonarSensor);

bool toScan = false;
int recordedDegree=0;

int TURNINGSPEED = 7;

// variables for test boundary
int MAX_BOUNDARY_EXPECTED = 4*100;
int rightBoundaryDegree = 0;
int leftBoundaryDegree = 0;

// DEFINED FUNCTION
void showInfo() {
	displayBigTextLine(2, "L: %d", leftBoundaryDegree);
	displayBigTextLine(4, "R: %d", rightBoundaryDegree);
}


void turn(int degreeToTurn){
	if (toScan) {startTask(getDistanceAndDegree);}
	degreeToTurn = degreeToTurn * 2;
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	if (degreeToTurn > 0) {
		setMotorTarget(leftMotor, degreeToTurn, TURNINGSPEED);
		setMotorTarget(rightMotor, -degreeToTurn, TURNINGSPEED);
		while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor)) {
			setMotorSync(leftMotor, rightMotor, 100, TURNINGSPEED);
		}
		} else if (degreeToTurn < 0) {
		degreeToTurn = -1 * degreeToTurn;
		setMotorTarget(leftMotor, -degreeToTurn, TURNINGSPEED);
		setMotorTarget(rightMotor, degreeToTurn, TURNINGSPEED);
		while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor)) {
			setMotorSync(leftMotor, rightMotor, -100, TURNINGSPEED);
		}
		if (toScan) {stopTask(getDistanceAndDegree);}
	}

}



void scan() {
	int scanDegree = 60;
	// scan right side
	toScan=true;
	turn(scanDegree);
	toScan=false;
	turn(-scanDegree);
	// scan left side
	toScan=true;
	turn(-scanDegree);
	toScan=false;
	turn(scanDegree);

	turn(targetDegree);
}


void turnOneMotor(bool leftMotorOrRightMotor, int motorEncoder)
{ // leftMotorOrRightMotor:
	// true, turn RIGHT motor,
	// false, turn LEFT motor.
	// motorEncoder, is the encoder you want the wheel to turn, positive means forward, negative means backward
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	if(leftMotorOrRightMotor) { // RightMotor move while LeftMotor stop
		if (motorEncoder > 0) { // move forward
			setMotorTarget(rightMotor, motorEncoder, TURNINGSPEED);
			while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor)) {
				setMotorSync(leftMotor, rightMotor, -50, TURNINGSPEED);
			}
			} else if (motorEncoder<0) { // move backward
			setMotorTarget(rightMotor, -motorEncoder, TURNINGSPEED);
			while(getMotorEncoder(rightMotor)!= -1*getMotorTarget(rightMotor)) {
				setMotorSync(leftMotor, rightMotor, -50, -TURNINGSPEED);
			}
		}
		} else {	// else false, LeftMotor move while RightMotor stop
		if (motorEncoder > 0) {
			setMotorTarget(leftMotor, motorEncoder, TURNINGSPEED);
			while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor)) {
				setMotorSync(leftMotor, rightMotor, 50, TURNINGSPEED);
			}
			} else if (motorEncoder < 0) {
			setMotorTarget(leftMotor, -motorEncoder, TURNINGSPEED);
			while(getMotorEncoder(leftMotor)!= -1*getMotorTarget(leftMotor)){
				setMotorSync(leftMotor, rightMotor, 50, -TURNINGSPEED);
			}
		}
	}
}


int turnOneMotorUntilMeetBoundary(bool leftOrRightMotor) {
		resetMotorEncoder(leftMotor);
		resetMotorEncoder(rightMotor);

		int saved_leftBoundaryDegree = 0;
		int saved_rightBoundaryDegree = 0;

		if(leftOrRightMotor) {
			 // turn RightMotor
			setMotorTarget(rightMotor, MAX_BOUNDARY_EXPECTED, TURNINGSPEED);
			while(getMotorEncoder(rightMotor)!=getMotorTarget(rightMotor) && getColorName(colorSensor)==colorBlack) {
				setMotorSync(leftMotor, rightMotor, -50, TURNINGSPEED);
			}

			saved_leftBoundaryDegree = getMotorEncoder(rightMotor);
			turnOneMotor(RIGHT, -1*saved_leftBoundaryDegree);
			return saved_leftBoundaryDegree;

		} else {
			setMotorTarget(leftMotor, MAX_BOUNDARY_EXPECTED, TURNINGSPEED);
			while(getMotorEncoder(leftMotor)!=getMotorTarget(leftMotor) && getColorName(colorSensor)==colorBlack) {
				setMotorSync(leftMotor, rightMotor, 50, TURNINGSPEED);
			}

			saved_rightBoundaryDegree = getMotorEncoder(leftMotor);
			turnOneMotor(LEFT, -1*saved_rightBoundaryDegree);
			return saved_rightBoundaryDegree;
		}
}



void testBoundary() {

	leftBoundaryDegree = turnOneMotorUntilMeetBoundary(RIGHT);
	rightBoundaryDegree = turnOneMotorUntilMeetBoundary(LEFT);
	int differences = abs(rightBoundaryDegree - leftBoundaryDegree);
	if(leftBoundaryDegree>rightBoundaryDegree) {
		turnOneMotor(RIGHT, differences/4);
		// turn(-differences/20);
		} else {
		turnOneMotor(LEFT, differences/4);
		//turn(differences/20);
	}

}


task main()
{
	//scan();
	testBoundary();
	//int saved_rightBoundaryDegree = 300;
	//// turnOneMotor(LEFT, saved_rightBoundaryDegree);
	//turnOneMotor(LEFT, -1*saved_rightBoundaryDegree);

}


task getDistanceAndDegree() {
	while(true) {
		recordedDegree = getMotorEncoder(leftMotor)/2;
		distance = getUSDistance(sonarSensor);
		if (distance < previousDistance) {
			previousDistance = distance;
			targetDistance = previousDistance;
			targetDegree = recordedDegree;
		}
	}
}
