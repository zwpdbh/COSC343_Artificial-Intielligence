#pragma config(Sensor, S4,     NXT2WIFI,       sensorHighSpeed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
 * benedettelli-nxt2wifi.h provides an API for Daniele's NXT2WiFi Sensor. This program
 * demonstrates how to use that API.  This program is opens a connection to a BOFH server
 * and fetches an excuse and displays it on the screen.  It is a demo for opening a TCP socket
 * to a remote host.
 *
 * Changelog:
 * - 0.1: Initial release
 *
 * Credits:
 * - Big thanks to Daniele Benedettelli for providing me with the hardware necessary to write and test this.
 *
 * License: You may use this code as you wish, provided you give credit where it's due.
 *
 * THIS CODE WILL ONLY WORK WITH ROBOTC VERSION 4.10 AND HIGHER

 * Xander Soldaat (xander_at_botbench.com)
 * 22 July 2012
 * version 0.1
 */

#include "common.h"
#include "benedettelli-nxt2wifi.h"

long txbytes = 0;
long rxbytes = 0;
string IPaddress = "0.0.0.0";
string connStatus = "disconnected";
string dataStrings[4];
tHugeByteArray data;
short sizeOfReceivedData;

task updateScreen()
{
  while(true)
  {
    displayTextLine(0, "Stat: %s", connStatus);
    displayTextLine(1, "%s",IPaddress);
    displayTextLine(2, "-------------------");
    displayTextLine(3, "%s", dataStrings[0]);
    displayTextLine(4, "%s", dataStrings[1]);
    displayTextLine(5, "%s", dataStrings[2]);
    displayTextLine(6, "%s", dataStrings[3]);
    displayTextLine(7, "RX/TX: %d/%d", rxbytes, txbytes);
    sleep(100);
  }
}

void processData()
{
  // Used for going through the current line so we
  // can print it
  string line = "";
  string singleword = "";

  // What line are we current printing on?
  short screenLine = 0;

  dataStrings[0] = "";
  dataStrings[1] = "";
  dataStrings[2] = "";
  dataStrings[3] = "";
  for (short i = 0; i < sizeOfReceivedData; i++)
  {
    // It's a printable character
    if (RS485rxbuffer[i] > 0x20)
    {
      // Append to the current word
      strncat(singleword, &RS485rxbuffer[i], 1);
    }
    // we've reached a word or line boundary
    else if ((RS485rxbuffer[i] == 0x20) || (RS485rxbuffer[i] == 0x0A))
    {
      // is the current word and the current line more than we can print?
      if ((strlen(line) + strlen(singleword)) > 16)
      {
        // print out the current line
        dataStrings[screenLine++] = line;
        // current word becomes new line
        memcpy(line, singleword, sizeof(singleword));
        // blank out the current word
        singleword = "";
      }
      else
      {
        // Append a space to the current line before sticking
        // the new word to it
        if (strlen(line) > 0)
          strcat(line, " ");
        strcat(line, singleword);
        singleword = "";
      }

      // Are we at the end of the line and need to print it out regardless?
      if (RS485rxbuffer[i] == 0x0A)
      {
        dataStrings[screenLine++] = line;
        // Reset the current line
        line = "";
      }
    }
  }
}
task main ()
{
  string BOFHserver = "192.168.0.100"; // Linux VM
  short BOFHport = 6666;
  string dataString;
  getFriendlyName(dataString);

  short avail = 0;

  nNxtButtonTask = -2;
  startTask(updateScreen);

  // initialise the port, etc
  RS485initLib();

  memset(RS485rxbuffer, 0, sizeof(RS485rxbuffer));
  memset(RS485txbuffer, 0, sizeof(RS485txbuffer));

  // Disconnect if already connected
  N2WDisconnect();
  N2WchillOut();

  if (!N2WCustomExist())
  {
    stopTask(updateScreen);
    sleep(50);
    eraseDisplay();
    playSound(soundException);
    displayCenteredBigTextLine(1, "ERROR");
    displayTextLine(3, "No custom profile");
    displayTextLine(4, "configured!!");
    while(true) sleep(1);
  }

  N2WLoad();

  sleep(100);
  N2WConnect(true);
  connStatus = "connecting";

  while (!N2WConnected())
    sleep(1000);

  connStatus = "connected";
  playSound(soundBeepBeep);

  sleep(3000);
  N2WgetIP(IPaddress);

  sleep(1000);

  while (true)
  {
    while (nNxtButtonPressed != kEnterButton) sleep(1);
    while (nNxtButtonPressed != kNoButton) sleep(1);
    if (N2WTCPOpenClient(1, BOFHserver, BOFHport)) {
      data[0] = 0x0A;
      N2WTCPWrite(1, data, 1);
      txbytes++;
      // How many bytes are available in the buffers?
      avail = N2WTCPAvail(1);
      if (avail > 0)
      {
        sizeOfReceivedData = avail;
        rxbytes += avail;
        N2WchillOut();
        // read the current buffer
        N2WTCPRead(1, avail);
        processData();
        for (short i = 0; i < avail; i++)
        {
          writeDebugStream("%c", RS485rxbuffer[i]);
        }
        writeDebugStreamLine("");
      }
      // Wait a bit
      N2WchillOut();
      // Disconnect
      N2WTCPClose(1);
    }
  }
}
