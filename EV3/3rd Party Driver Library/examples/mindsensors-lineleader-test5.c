#pragma config(Sensor, S1,     LLEADER,             sensorI2CCustomFastSkipStates9V)
#pragma config(Sensor, S4,     NUMPAD,              sensorI2CCustomFastSkipStates)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/** \file mindsensors-lineleader-test5.c
 * \brief Mindsensors LineLeader Sensor demo program
 *
 * MSLL-test5.c is a demo program for the Mindsensors LineLeader Sensor.
 *
 * Changelog:
 * - 0.1: Initial release
 * - 0.2: Reworked to use new driver API
 * - 0.3: More comments<br>
 *        Use clip() instead of manual clipping
 * - 0.4: Removed common.h from includes\n
 *        Replaced arrays with new type that does not use structs
 *
 * Credits:
 * - Big thanks to Mindsensors for providing me with the hardware necessary to write and test this.
 *
 * License: You may use this code as you wish, provided you give credit where its due.
 *
 * THIS CODE WILL ONLY WORK WITH ROBOTC VERSION 4.10 AND HIGHER

 * Xander Soldaat (xander_at_botbench.com)
 * 14 February 2011
 * version 0.4
 */

#define MSLL_I2C_ADDR 0x02

#include "mindsensors-lineleader.h"
#include "mindsensors-numericpad.h"

// The PID constants and base speed
#define DEFAULT_SP   50

// The file for the log data
#define LOGFILE   "linelead.dat"

#define MENUITEMS 5

// function prototypes
void doMainMenu();
void doMenuItem(short activeOption);
bool checkTimer(TTimers timer);
void doLineLead();
void writeParams();

string menuHeader;
string menuFooter;

const TTimers rightButtonTimer = T1;
const TTimers leftButtonTimer  = T2;

short activeOption = 0;

short keep_running = 0;

byte sensor = 0;

// array to hold user entered values
short params[4];

string optionMainMenu[] = {
                              "Kp",
                              "Ki",
                              "Kd",
                              "Sp",
                              "Run" };

string optionMainMenuFooter[] = {
                             //123456789012345678
                              "*=Exit     #=Edit",
                              "*=Exit     #=Edit",
                              "*=Exit     #=Edit",
                              "*=Exit     #=Edit",
                              "*=Exit     #=Run " };

tByteArray signalstr;

short getNumber(tSensors link, short &_number, short numdigits=3, short timeout=0) {
  long starttime = nPgmTime;
  short tmpnum, prevnum, counter = 0;

  //_number = 0;

  while (true) {
    if ((timeout != 0) && nPgmTime > (starttime + timeout))
      return -1;

    // Read the keypad
    tmpnum = MSNPscanKeys(NUMPAD);

    // Reset the timer if a key has been pressed
    if (tmpnum != -255) {
      starttime = nPgmTime;
    }

    // Make sure we're not going beyond the requested length
    if ((counter >= numdigits) && (tmpnum >= 0))
      continue;

    if ((tmpnum >= 0) && (prevnum != tmpnum)) {
      playSound(soundBlip);
      while(bSoundActive) sleep(1);
      if ((counter == 0) && (tmpnum >= 0)) {
        _number = tmpnum;
        counter++;
      } else {
        _number = _number*10 + tmpnum;
        counter++;
      }
    } else if (tmpnum == -1) {
      return (counter > 0) ? 0 : -1;
    } else if (tmpnum == -2) {
      return -2;
    }

    prevnum = tmpnum;
  }
  return 0;
}

//task batteryMonitor() {
//  while (true) {
//    if (nAvgBatteryLevel < 6200) {
//      playSound(soundBeepBeep);
//      while(bSoundActive) sleep(1);
//      playSound(soundBeepBeep);
//      while(bSoundActive) sleep(1);
//      stopAllTasks();
//    }
//    sleep(500);
//  }
//}

// This function draws the current values of the sensor and other data on the screen
// in a visually pleasing way
task drawSensors() {
  while (keep_running == 1) {
    // This clears the entire area occupied by the small rectangles
    eraseRect(6,62, 91, 43);
    for (short i = 0; i < 8; i++) {
      // Draw the rectangles for the signal strength first
      drawRect(6+(i*11),62, 14+(i*11), 50);
      fillRect(6+(i*11),51+signalstr[i]/10, 14+(i*11), 50);
      // Draw a black rectangle if the sensor has detected the line,
      // a hollow one when nothing has been detected.
      if ((sensor >> i) & 1) {
        fillRect(6+(i*11),48, 14+(i*11), 43);
      } else {
        drawRect(6+(i*11),48, 14+(i*11), 43);
      }
    }
    sleep(100);
  }
}

// Keep the robot on the line!
task followTheYellowBrickRoad () {
  short powerA = 0;
  short powerC = 0;
  byte steering = 0;

  eraseDisplay();
  displayCenteredTextLine(3, "Running...");
  displayCenteredTextLine(5, "Press exit or *");
  displayCenteredTextLine(6, "to stop");

  time1[T4] = 0;
  while (keep_running == 1) {
    if (MSNPscanKeys(NUMPAD) == -2)
      keep_running = 0;

    steering = LLreadSteering(LLEADER);
    sensor = LLreadResult(LLEADER);
    //average = LLreadAverage(LLEADER);
    LLreadSensorRaw(LLEADER, signalstr);

    steering /= 2;

    powerA = (params[3] - steering);
    powerC = (params[3] + steering);

    // If your robot is going in the wrong direction, comment out the
    // lines above and uncomment the lines below.
    //powerA = (params[3] - steering);
    //powerC = (params[3] + steering);

    // this clips the values
    powerA = clip(powerA, -100, 100);
    powerC = clip(powerC, -100, 100);

    //if(powerA>100)  powerA=100;
    //if(powerA<-100) powerA=-100;
    //if(powerC<-100) powerC=-100;
    //if(powerC>100)  powerC=100;

    motor[motorA] = -(byte)powerA;
    motor[motorC] = -(byte)powerC;
    sleep(1);
    if (sensor != 0xFF) {
      time1[T4] = 0;
    } else if (time1[T4] > 500) {
      keep_running = 0;
    }
  }

  motor[motorA] = 0;
  motor[motorC] = 0;
}

task redrawMenu() {
  while(true) {
    eraseDisplay();
    displayTextLine(0, menuHeader);
    for (short i = 0; i < MENUITEMS; i++) {
      displayClearTextLine(i + 1);
      if (i == activeOption) {
        if (i < 4)
          displayTextLine(i + 1, "> %s [%3d] <", optionMainMenu[i], params[i]);
        else
          displayTextLine(i + 1, "> %s      <", optionMainMenu[i]);
        displayTextLine(7, menuFooter);
      } else {
        if (i < 4)
          displayTextLine(i + 1, "  %s [%3d]", optionMainMenu[i], params[i]);
        else
          displayTextLine(i + 1, "  %s", optionMainMenu[i]);
      }
    }
    sleep(100);
  }
}

// Main task
task main () {

//  memcpy(params, default_params, sizeof(default_params));

  params[0] = LLreadKp(LLEADER);
  params[1] = LLreadKi(LLEADER);
  params[2] = LLreadKd(LLEADER);
  params[3] = DEFAULT_SP;

  // Set the default parameters and write them to the sensor

  //writeParams();

  nNxtButtonTask  = -2;
  nNxtExitClicks = 3;

  startTask(redrawMenu);
  doMainMenu();
  while(true)
    sleep(100);
}

// Draw the main menu
void doMainMenu () {
  while (true) {
    menuHeader = "  2/8 => up/down";

    //stringFormat(menuFooter, "%s", optionMainMenuFooter[activeOption]);
    menuFooter = optionMainMenuFooter[activeOption];

    switch(MSNPscanKeys(NUMPAD)) {
      case 8:
            if (!checkTimer(rightButtonTimer)) {
              break;
            }
            if (activeOption == (MENUITEMS - 1))
              activeOption = 0;
            else
              activeOption++;
            //stringFormat(menuFooter, "%s", optionMainMenuFooter[activeOption]);
            menuFooter = optionMainMenuFooter[activeOption];
            sleep(300);
            break;
      case 2:
            if (!checkTimer(leftButtonTimer)) {
              break;
            }
            if (activeOption == 0)
              activeOption = (MENUITEMS - 1);
            else
              activeOption--;
            //stringFormat(menuFooter, "%s", optionMainMenuFooter[activeOption]);
            menuFooter = optionMainMenuFooter[activeOption];
            sleep(300);
            break;
      case -1:
            if (!checkTimer(rightButtonTimer)) {
              break;
            }
            sleep(600);
            doMenuItem(activeOption);
            break;
      case -2:
            sleep(500);
            stopAllTasks();

    }
  }
}

// When enter is pressed in the doMainMenu() we come here.
// Here we handle the actual actions for each menu item.
void doMenuItem(short activeOption) {
  long oldnumber = 0;
  short retval = 0;

  playSound(soundBlip);
  while(bSoundActive) sleep(1);

  if (activeOption == 4) {
    doLineLead();
    return;
  }

  if (activeOption == 3)
    menuHeader = "Enter nr (0-100)";
  else
    menuHeader = "Enter nr (0-127)";

              //123456789012345678
  menuFooter = "*=No Save  #=Save";

  oldnumber = params[activeOption];

  retval = getNumber(NUMPAD, params[activeOption], 3, 5000);

  switch (retval) {
    case -2:  // aborted
              params[activeOption] = oldnumber;
              writeParams();
              sleep(1000);
              break;
     case -1: // Nothing entered
              params[activeOption] = oldnumber;
              writeParams();
              sleep(1000);
              return;
              break;
     case 0:  // A number was entered
              if (activeOption == 3 && params[activeOption] > 100 )
                params[activeOption] = oldnumber;
              else if (params[activeOption] > 127)
                params[activeOption] = oldnumber;
              writeParams();
              sleep(1000);
              return;
              break;
   }
}

// See if more than 300ms has elapsed
bool checkTimer(TTimers timer) {
  if (time1[timer] < 300) {
    return false;
  } else {
    time1[timer] = 0;
    return true;
  }
}

// Start and stop the line following task (followTheYellowBrickRoad)
void doLineLead() {
  sensor = 0;
  stopTask(redrawMenu);
  keep_running = 1;
  eraseDisplay();
  // Count down and
  for (short i = 0; i < 5; i++) {
    displayCenteredBigTextLine(3, "%d", 5-i);
    playSound(soundBlip);
    sleep(600);
  }
  playSound(soundFastUpwardTones);
  while(bSoundActive) sleep(1);
  startTask(drawSensors);
  startTask(followTheYellowBrickRoad);
  while(nNxtButtonPressed != kExitButton && keep_running != 0) {
    sleep(10);
  }
  // this will kill off the followTheYellowBrickRoad task
  keep_running = 0;
  sleep(1000);
  startTask(redrawMenu);
}

// Write the PID values to the LineLeader sensor
void writeParams() {
  LLsetKp(LLEADER, params[0], 32);
  LLsetKi(LLEADER, params[1], 32);
  LLsetKd(LLEADER, params[2], 32);
}
