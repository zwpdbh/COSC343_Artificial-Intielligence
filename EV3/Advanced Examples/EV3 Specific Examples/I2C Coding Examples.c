#pragma config(Sensor, S4,     I2CSENSOR,      sensorEV3_GenericI2C)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//////////////////////////////////////////////////////////////////////////////////////////
//
//                           I2C Coding Source Code Examples
//                           ===============================
//
// Contains code snippets for working with the Legacy NXT I2C sensors on a EV3 brick.
//
////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////
//
//                waitForI2CReply(TSensors nPortIndex, const int nReplyLength)
//
// Function will delay waiting for last I2C transaction to finish.
//
//////////////////////////////////////////////////////////////////////////////////////////

bool waitForI2CReply(tSensors nPortIndex)
{
	while (nI2CStatus[nPortIndex] == i2cStatusPending)
		wait1Msec(1);

	//if (nI2CBytesReady[nPortIndex] != nReplyLength)
	//	return false;

	return true;
}


//////////////////////////////////////////////////////////////////////////////////////////
//
//                           Read from an I2C Device
//
// Sends a message to I2C sensor to read data from the device. You'll have to poll the
// status of the I2C communications channel to tell when the 'read' is complete.
//
//////////////////////////////////////////////////////////////////////////////////////////

bool sendSensorRead(tSensors nPortIndex, const ubyte &nSendMsg, const int nReplyLength)
{
	TI2CStatus nStatus;

	if (nI2CStatus[nPortIndex] == i2cStatusPending)
		return false;   // Can't send message to a busy device

	nStatus = sendI2CMsg(nPortIndex, &nSendMsg, nReplyLength);
	return (nStatus == i2cStatusNoError);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
//                        readI2CReply(TSensors nPortIndex)
//
// Collects the reply bytes from an I2C message.
//
//////////////////////////////////////////////////////////////////////////////////////////

bool readSensorReply(tSensors nPortIndex, ubyte *pReplyMsg, const int nReplyLength)
{
	TI2CStatus nStatus;

	if (!waitForI2CReply(nPortIndex))
	{
	  memset(pReplyMsg, 0, nReplyLength);
	  return false;
	}

	nStatus = readI2CReply(nPortIndex, pReplyMsg, nReplyLength);
	return (nStatus == i2cStatusNoError);
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//          Sample Task to Continuously read the sensor characteristics
//
////////////////////////////////////////////////////////////////////////////////////////////

int nMsgCountGood = 0;
int nMsgCountTimeout = 0;

task main()
{
	const int kI2CAddress    = 0x02;    // You may want to make this a function parameter
	const int kRegisterIndex = 0x00;    // You may want to make this a function parameter

	static const ubyte nReadDeviceID[] =
	{
		2,                   // This is length field for transmitted message.
		kI2CAddress,         // The I2C address of the device. Almost all devices use value '0x02'
		kRegisterIndex,      // The internal register index within the sensor to start writing at.
	};

	const int kReplyLength = 8;         // You might want to make this a function parameter.
	static ubyte nReplyBytes[kReplyLength];

  clearDebugStream();

  while ((nMsgCountGood + nMsgCountTimeout) < 1000)
  {
    clearTimer(T1);
    sendSensorRead(I2CSENSOR, nReadDeviceID[0], kReplyLength);
    while (true)
    {
    	if (nI2CStatus[I2CSENSOR] == i2cStatusPending)
    	{
    		if (time1[timer1] > 48)
	    	{
	    		++nMsgCountTimeout;
	    		break;
	    	}
    	}
    	else if (nI2CStatus[I2CSENSOR] == i2cStatusNoError)
    	{
    		readSensorReply(I2CSENSOR, &nReplyBytes[0], kReplyLength);
    		++nMsgCountGood;
    		break;
    	}
    	else
    	{
  			++nMsgCountTimeout;
    		break;
    	}
    }
  }
  writeDebugStreamLine("Total: %d", nMsgCountGood + nMsgCountTimeout);
  writeDebugStreamLine("Good: %d", nMsgCountGood);
  writeDebugStreamLine("Tout: %d", nMsgCountTimeout);
}
